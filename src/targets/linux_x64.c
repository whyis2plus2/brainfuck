#include <stdio.h>

#include "../context.h"
#include "../errors.h"

#if defined(__linux__) && defined(__x86_64__)
int BF_compile_context(BF_Context *ctx, const char *output_file)
{
  if (!ctx) return BF_ERR_INVALID_PARAM;
  
  int test = BF_test_context(ctx);
  if (test) return test;

  FILE *out = fopen(output_file, "w+");
  if (!out) return BF_ERR_COULD_NOT_OPEN_FILE;

  fprintf(
    out,
    "# gas x64 linux\n"
    "# generated by whyis2plus2's brainfuck compiler\n"
    "# link with \"gcc -static (object file) -o (executable)\"\n\n"
    ".global main\n\n"
    ".text\n"
    "main:\n"
    "\tpush %%rbp\n"
    "\tmovq %%rsp, %%rbp\n"
    "\tmovq $%zu, %%rdi\n"
    "\tmovq $1, %%rsi\n"
    "\tcall calloc@plt\n"
    "\tmovq %%rax, %%r12\n",
    ctx->num_cells
  );

  for (size_t i = 0; i < ctx->tokens.len; ++i) {
    const BF_Token tok = ctx->tokens.data[i];

    switch (tok.type) {
      case BF_NUM_TOKEN_TYPES:
      case BF_TOK_NONE: break;

      case BF_TOK_ARITH:
        fprintf(out, "\taddb $%u, (%%r12)\n", (uint8_t)tok.arith.amount);
        break;

      case BF_TOK_MOVIDX:
        fprintf(out, "\taddq $%ju, %%r12\n", tok.mov_idx.amount);
        break;

      case BF_TOK_BEGIN_LOOP:
        BF_jump_list_push(&ctx->loops, i);
        fprintf(out, ".Lloop_%zu:\n", i);
        break;

      case BF_TOK_END_LOOP:
        fprintf(
          out,
          "\tcmpb $0, (%%r12)\n"
          "\tjne .Lloop_%zu\n",
          ctx->loops.indicies[ctx->loops.len - 1]
        );

        --ctx->loops.len;
        break;
      
      case BF_TOK_PRINT:
        fprintf(
          out, 
          "\tmovb (%%r12), %%dil\n"
          "\tcall putchar@plt\n"
        );

        break;

      case BF_TOK_INPUT:
        fprintf(
          out,
          "\tcall getchar@plt\n"
          "\tmovb %%al, (%%r12)\n"
        );

        break;
    }
  }

  fprintf(
    out,
    "\txorq %%rdi, %%rdi\n"
    "\tcall exit\n"
  );

  fclose(out);
  return 0;
}
#endif
