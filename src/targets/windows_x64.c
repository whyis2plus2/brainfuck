#include <stdio.h>

#include "../context.h"
#include "../errors.h"

#ifdef _WIN64
int BF_compile_context(BF_Context *ctx, const char *output_file)
{
  if (!ctx) return BF_ERR_INVALID_PARAM;
  
  FILE *out = fopen(output_file, "w+");
  if (!out) return BF_ERR_COULD_NOT_OPEN_FILE;

  fprintf(
    out,
    "# gas x64 windowsNT\n"
    "# generated by whyis2plus2's brainfuck compiler\n"
    "# link with \"gcc -static (object file) -o (executable)\"\n\n"
    ".global main\n\n"
    ".text\n"
    "main:\n"
    "\tpush %%rbp\n"
    "\tmovq %%rsp, %%rbp\n"
    "\tmovq $%zu, %%rcx\n"
    "\tmovq $1, %%rdx\n"
    "\tcall calloc\n"
    "\tmovq %%rax, %%r12\n",
    ctx->num_cells
  );

  for (size_t i = 0; i < ctx->tokens.len; ++i) {
    // printf("Token: %s\n", BF_get_token_name(ctx.tokens.data[i]));
    enum BF_Token const token = ctx->tokens.data[i];

    switch (token) {
      case BF_TOK_NONE: break;

      case BF_TOK_INC:
        fprintf(out, "\tincb (%%r12)\n");
        break;

      case BF_TOK_DEC:
        fprintf(out, "\tdecb (%%r12)\n");
        break;

      case BF_TOK_NEXT:
        fprintf(out, "\tincq %%r12\n");
        break;

      case BF_TOK_PREV:
        fprintf(out, "\tdecq %%r12\n");
        break;

      case BF_TOK_BEGIN_LOOP:
        BF_jump_list_push(&ctx->loops, i);
        fprintf(out, ".Lloop_%zu:\n", i);
        break;

      case BF_TOK_END_LOOP:
        fprintf(
          out,
          "\tcmpb $0, (%%r12)\n"
          "\tjne .Lloop_%zu\n",
          ctx->loops.indicies[ctx->loops.len - 1]
        );

        --ctx->loops.len;
        break;
      
      case BF_TOK_PRINT:
        fprintf(
          out, 
          "\tmovb (%%r12), %%cl\n"
          "\tcall putchar\n"
        );

        break;

      case BF_TOK_INPUT:
        fprintf(
          out,
          "\tcall getchar\n"
          "\tmovb %%al, (%%r12)\n"
        );

        break;
    }
  }

  fprintf(
    out,
    "\txorq %%rcx, %%rcx\n"
    "\tcall exit\n"
  );

  fclose(out);
  return 0;
}
#endif
